## vuex 流程图

![ vuex 流程图](https://vuex.vuejs.org/vuex.png)

## 安装使用

安装 
```
npm install vuex --save
```

使用

```
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)
```

## State

state 使用：

```js
const store = new Vuex.Store({
    store:{
        count:0,
        name:"jack",
        age:18,
        sex:"male"
    }
})
```

mapState 使用：

```js
// 在单独构建的版本中辅助函数为 Vuex.mapState
import { mapState } from 'vuex'
export default {
    computed:{
        // 对象展开语法
        ...mapState({
            // 使用箭头函数
            count:state=>state.count,
            // 使用字符串,将state.name 绑定到计算属性studentName上
            studentName:"name",
            // 使用函数
            countPlusLocalState(state){
                return state.count * 10
            }
        }),
        // 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。
        ...mapState(["age","sex"]),//将age sex绑定到computed上
    }
}
```

## Getter

> Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被`缓存`起来，且只有当它的`依赖值发生了改变才会被重新计算`。

getters 使用：

```js
const store = new Vuex.store({
    state:{
        todos:[
            {id:1, title:"study", done:true},
            {id:2, title:"eat", done:false},
            {id:3, title:"run", done:true},
            {id:4, title:"go swimming", done:false},
        ]
    },
    getters:{
        // 返回已做todo，getter的一个参数为state
        doneTodos(state){
            return state.todos.filter(todo=>todo.done)
        },
        // 返回已做todo个数，getter的第二个参数为getters
        doneTodosCount(state,getters){
            return getters.doneTodos.length
        },
        // 通过方法访问
        getTodoByID(state){
            return (id)=>{
                return state.todos.find((todo=>todo.id === id))
            }
        }
    }
})
```
mapGetters 使用

> mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：

```js
import { mapGetters } from 'vuex';

export default {
    // 数组方法
    ...mapGetters(["doneTodos","doneTodosCount"]),
    // 对象方法
    ...mapGetters({getTodoByID:"getTodoByID"})
}
```

## Mutation

> 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation

mutation 基本使用:
```js
const store = new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      // 变更状态
      state.count++
    }
  }
})
```
```js
store.commit('increment')
```

mutation 提交载荷（Payload）

```js
const store = new Vuex.Store({
    state: {
        count: 1
    },
    mutations: {
        increment (state,n) {
            // 变更状态
            state.count += n
        }
    }
})
```
```js
store.commit('payload',5)
```

在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：

```js
const store = new Vuex.Store({
    state: {
        count: 1
    },
    mutations: {
        increment (state,payload) {
            // 变更状态
            state.count += payload.n
        }
    }
})
```

```js
store.commit('payload',{
    n:5
})
```

对象风格的提交方式:提交 mutation 的另一种方式是直接使用包含 type 属性的对象

```js
store.commit({
    type:"increment",
    n:10
})
```
当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：

```js
const store = new Vuex.Store({
    state: {
        count: 1
    },
    mutations: {
        increment (state,payload) {
            // 变更状态
            state.count += payload.n
        }
    }
})
```

Mutation 需遵守 Vue 的响应规则

1. 最好提前在你的 store 中初始化好所有所需属性。
2. 当需要在对象上添加新属性时，你应该
    + 使用 Vue.set(obj, 'newProp', 123), 或者
    + 以新对象替换老对象。例如，利用对象展开运算符 (opens new window)我们可以这样写：
        ```js
        state.obj = { ...state.obj, newProp: 123 }
        ```

mutation必须是同步函数 , 有异步操作在action中执行

mapMutations 辅助函数的基本使用:

```js
import { mapMutations } from 'vuex'
export default {
   // ...
   methods: {
      ...mapMutations([
         'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`

         // `mapMutations` 也支持载荷：
         'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`
      ]),
      ...mapMutations({
         add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`
      })
   }
}
```

## Action

Action 类似于 mutation，不同在于：
   + action 提交的是 mutation，而不是直接变更状态。
   + action 中可以执行任何异步操作

action 的基本使用

```js
const store = new Vuex.store({
   state:{
       count:0
   },
   mutations:{
      increment(state,payload){
          state.count += payload.n
      }
   },
   actions:{
      increment(context,paylod){
           setTimeout(()=>{
               context.commit('increment',paylod)
           },3000)
       }
   }
})
```
```js
// 以载荷形式分发
store.dispatch('increment',{
    n:10
})
// 以对象形式分发
store.dispatch({
   type:"addincrement",
   n:10
})
```

mapActions 的基本使用

```js
import { mapActions } from 'vuex'

export default {
  // ...
  methods: {
    ...mapActions([
      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`

      // `mapActions` 也支持载荷：
      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`
    ]),
    ...mapActions({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`
    })
  }
}
```

## Module

module 的基本使用

```js
const moduleA = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -> moduleA 的状态
store.state.b // -> moduleB 的状态
```

模块的局部状态

> 对于模块内部的 mutation 和 getter，接收的第一个参数是`模块的局部状态对象`。

```js    <option value="5">5</option>
  </select>
  <button @click="add">+</button>
  <button @click="sub">-</button>
  <button @click="addOdd">odd +</button>
  <button @click="addAsync">async +</button>
</div>
</template>

<script>
export default {
  name: "Count",
  data(){
     return{
       number:1
     }
  },
  methods:{
    add(){
      this.$store.commit("add",this.number)
    },
    sub(){
      this.$store.commit("sub",this.number)
    },
    addOdd(){
      this.$store.dispatch("addOdd",this.number)
    },
    addAsync(){
      this.$store.dispatch("addAsync",this.number)
    },
  },
}
</script>

<style scoped>

</style>
const moduleA = {
  state: () => ({
    count: 0
  }),
  mutations: {
    increment (state) {
      // 这里的 `state` 对象是模块的局部状态
      state.count++
    }
  },

  getters: {
    doubleCount (state) {
      return state.count * 2
    }
  }
}
```
> 同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：
```js
const moduleA = {
   // ...
   actions: {
      incrementIfOddOnRootSum ({ state, commit, rootState }) {
         if ((state.count + rootState.count) % 2 === 1) {
            commit('increment')
         }
      }
   }
}
```
> 对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：

```js
const moduleA = {
  // ...
  getters: {
    sumWithRootCount (state, getters, rootState) {
      return state.count + rootState.count
    }
  }
}
```
> 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。

```js
const store = new Vuex.Store({
  modules: {
    account: {
      namespaced: true,

      // 模块内容（module assets）
      state: () => ({ ... }), // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响
      getters: {
        isAdmin () { ... } // -> getters['account/isAdmin']
      },
      actions: {
        login () { ... } // -> dispatch('account/login')
      },
      mutations: {
        login () { ... } // -> commit('account/login')
      },

      // 嵌套模块
      modules: {
        // 继承父模块的命名空间
        myPage: {
          state: () => ({ ... }),
          getters: {
            profile () { ... } // -> getters['account/profile']
          }
        },

        // 进一步嵌套命名空间
        posts: {
          namespaced: true,

          state: () => ({ ... }),
          getters: {
            popular () { ... } // -> getters['account/posts/popular']
          }
        }
      }
    }
  }
})
```

在带命名空间的模块内访问全局内容（Global Assets）

> 如果你希望使用全局 state 和 getter，rootState 和 rootGetters 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。



module 个人总结

1. 使用state store.state.moduleName.keyName
2. mutation action getter 的使用事项
   1. mutation 方法第一个参数state是局部state
   2. action 方法第一个参数context 局部state是context.state 全局state是context.rootState
   3. getter 方法第一个参数state是局部state 第二个参数getters是局部getters,第三个参数rootState是全局state,第四个参数是rootGetter是全局getter
3. 提交mutation 分发action 获取getter 的基本使用
   1. 当namespaced:false(默认)时,module中的mutation/action/getter,以原有名字挂在到store.
   2. 当namespaced:true是,module中的mutation/action/getter,在原有名字前面加moduleName/的形式挂在到store.
   3. 当namespaced:false(默认)时,getter 重复会报错,mutation action 会追加到数组 一起调用
4. 若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。
   ```js
   modules: {
     foo: {
       namespaced: true,
   
       getters: {
         // 在这个模块的 getter 中，`getters` 被局部化了
         // 你可以使用 getter 的第四个参数来调用 `rootGetters`
         someGetter (state, getters, rootState, rootGetters) {
           getters.someOtherGetter // -> 'foo/someOtherGetter'
           rootGetters.someOtherGetter // -> 'someOtherGetter'
         },
         someOtherGetter: state => { ... }
       },
   
       actions: {
         // 在这个模块中， dispatch 和 commit 也被局部化了
         // 他们可以接受 `root` 属性以访问根 dispatch 或 commit
         someAction ({ dispatch, commit, getters, rootGetters }) {
           getters.someGetter // -> 'foo/someGetter'
           rootGetters.someGetter // -> 'someGetter'
   
           dispatch('someOtherAction') // -> 'foo/someOtherAction'
           dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'
   
           commit('someMutation') // -> 'foo/someMutation'
           commit('someMutation', null, { root: true }) // -> 'someMutation'
         },
         someOtherAction (ctx, payload) { ... }
       }
     }
   }
   ```
   
## 严格模式

```js
const store = new Vuex.Store({
   strict:true//开启严格模式,只能在mutation中修改state
})
```


## 表单处理

```html
<input v-model="obj.message">
```

当obj.message 是store中的数据时,在严格模式下会报错,因为严格模式下,state只能在mutation中修改.

解决方式:
   
   1. 通过事件.
      ```html
      <template>
         <div>
            <input type="text" :value="$store.state.demo" @input="changeValue">
         </div>
      </template>
      
      <script>
         export default {
            methods:{
               changeValue(event){
                  this.$store.commit('setDemo',event.target.value)
               }
            }
         }
      </script>
      ```
      ```js
      const store = new Vuex.Store({
          strict:true,
          state:{
              demo:19
          },
          mutations:{
              setDemo(state,value){
                  state.demo = value
              }
          }
      })
      ```
      
   2. 通过计算属性
      ```html
      <input type="text" v-model="message">
      ```
      ```js
      export default {
        computed:{
          message:{
            get(){
              return this.$store.state.demo
            },
            set(value){
              this.$store.commit('setDemo',value)
            }
          }
        }
      }
      ```