## class和style的基本绑定

### class 绑定方法

> class 对象绑定

```html
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
```
```
data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
```

> class 数组绑定

```html
<div v-bind:class="[activeClass, errorClass]"></div>
```

```
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
```

> 小技巧

+ class 对象绑定可以绑定一个属性对象/计算属性对象

```html
<div v-bind:class="classObject"></div>
```
```
data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
```

```
data: {
  isActive: true,
  error: null
},
computed: {
  classObject: function () {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
    }
  }
}
```

+ 数组绑定class可以使用三目运算

```html
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
```

+ 数组绑定class可以使用对象

```html
<div v-bind:class="[{ active: isActive }, errorClass]"></div>
```

> 用在组件上

当在一个自定义组件上使用 class property 时，这些 class 将被添加到`该组件的根元素上面`。这个元素上`已经存在的 class 不会被覆盖`。

### style 绑定方法

> style 对象绑定

```html
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```
```
data: {
    activeColor: 'red',
        fontSize: 30
}
```

使用大驼峰式命名  可以绑定一个属性对象/计算属性对象

> 对象语法

v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：
```html
<div v-bind:style="[baseStyles, overridingStyles]"></div>
```

## 计算属性和侦听器

> computed

有缓存 有getter 和 setter 方法 简写形式省去 setter方法

getter的调用:

1. 初始化
2. 所依赖data的改变


> methods

方法函数 无缓存

> watch

监听方法 

```js
let vm = new Vue({
    el:"#app",
    data(){
        return{
            age:18,
            book:{
                id:1,
                name:"三国演义",
                author:"罗贯中"
            }
        }
    },
    watch:{
        age:{
            immediate:true,
            handler(newValue,oldValue){
                
            }
        },
        //检测多级属性某个的变化
        'book.id':{
            handler(newValue,oldValue){

            }
        },
        book:{
            deep:true,
            handler(newValue,oldValue){

            }
        }
    }
})
// 监听方法第二种使用
vm.$watch('age',{
    immediate:true,
    handler(newValue,oldValue){

    }
})
```

配置参数:
+ handler 监听属性改变的回调函数
+ deep 监听引用类型内部值改变
+ immediate 监听后立即调用

简写方法
```
  watch: {
    // 如果 `question` 发生改变，这个函数就会运行
    question: function (newQuestion, oldQuestion) {
      this.answer = 'Waiting for you to stop typing...'
      this.debouncedGetAnswer()
    }
  },
```

> 计算属性和watch的区别

watch可以开启异步任务,computed不支持异步任务

## 列表渲染

> 遍历数组

```html
<ul v-for="(book,index) in books" :key="index">
    <li>{{index}} : {{book}}</li>
</ul>
```
```js
let vm = new Vue({
    el:"#app",
    data(){
        return{
            books:["红楼梦","西游记","三国演义","水浒传"]
        }
    }
})
```
> 遍历对象

```html
<ul v-for="(book,name,index) in book">
    <li>{{index}} + {{name}} + {{book}}</li>
</ul>
```
```js
let vm = new Vue({
    el:"#app",
    data(){
        return{
            book:{
                id:1,
                name:"三国演义",
                author:"罗贯中"
            }
        }
    }
})
```
> 变更方法

+  push()
+  pop()
+  shift()
+  unshift()
+  splice()
+  sort()
+  reverse()


## 事件处理



> v-on:eventName="methodName"

语法糖 @eventName="methodName"

event 参数 可以使用 vue 内置 $event传入

> 事件修饰符

+ .stop
+ .prevent
+ .capture
+ .self
+ .once
+ .passive

> 按键修饰符
+ .enter
+ .tab
+ .delete (捕获“删除”和“退格”键)
+ .esc
+ .space
+ .up
+ .down
+ .left
+ .right

## 表单输入绑定

> v-model

+ 文本 `<input type="checkbox" id="checkbox" v-model="checked">`
+ 多行文本 `<textarea v-model="message" placeholder="add multiple lines"></textarea>`
+ 复选框 `<input type="checkbox" id="checkbox" v-model="checked">`
+ 单选按钮
```html
<div id="example-4">
  <input type="radio" id="one" value="One" v-model="picked">
  <label for="one">One</label>
  <br> 
  <input type="radio" id="two" value="Two" v-model="picked">
  <label for="two">Two</label>
  <br>
  <span>Picked: {{ picked }}</span>
</div>
```
+ 选择框

```html
<div id="example-5">
  <select v-model="selected">
    <option disabled value="">请选择</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <span>Selected: {{ selected }}</span>
</div>
```

> 修饰符

+ .lazy
+ .number
+ .trim


## 内置指令总结

+ v-text
+ v-html  
+ v-on
+ v-bind
+ v-cloak
+ v-once
+ v-pre

## vue自定义指令

```html
<div id="app">
    <input v-model="message" placeholder="edit me">
    <p>Message is: {{ message }}</p>
    <p v-big="message"></p>
</div>
```
```js
    let vm = new Vue({
        el:"#app",
        data(){
            return{
                message:""
            }
        },
       directives:{
            big(el,binding){
                el.innerText = binding.value * 10
            },
           big2:{
                bind(el,binding){
                    el.innerText = binding.value * 10
                },
               inserted(el,binding){
                    
               },
               update(el,binding){
                   el.innerText = binding.value * 10
               },
           }
       }
    })
```

v-xx:yyy="" 的形式 yyy在binding 中的 arg 参数中

当bind 和 update 钩子函数行为一致,且不关心其他钩子函数,可以使用自定义指令的简写形式

## props

让组件接收父组件传来的数据

1. 传递数据: 通过标签属性 `<Student name="tom" :age="18" sex="female/>`

2. 接收数据: 
   
   a. 数组接收 `props:["name","age","sex"]`
   
   b. 对象接受
   ```
    props: {
        name:{
            type:String,
            require:true
        },
        sex:{
            type:String,
            default:"male"
        },
        age:{
            type:Number,
            require: true,
            default: 18
        }
    }
   ```

eg:props 是只读的 , vue底层会检测对props的改变,如果更改 vue 会抛出警告,非要更改,新增别名属性到data中

## mixin

混入一个对象 到 vue实例/vue组件示例.

局部混入: mixin:[mixin1,mixin2,...]

全局混入: Vue.mixin(mixin1)  Vue.mixin(mixin2)  影响全部vue实例 不推荐使用

属性/方法 优先vue示例中的方法 ,钩子函数中的代码先执行vue实例中的代码 再执行mixin中的代码

## 自定义事件

基本使用

定义自定义事件: 

1. `@xxx="eventHandle"`
2. 使用$on 和 ref
```
x-ref="student"
this.$refs.stident.$on("xxx",this.eventHandle)
```

触发自定义事件 

`this.$emit("xxx",params)`

解绑自定义事件

```
this.$off()//解绑组件全部自定义事件
this.$off('xxx')//解绑组件xxx自定义事件
this.$off(['xxx','yyy'])//解绑组件xxx,yyy自定义事件
```


## 全局事件总线

1. 一种组件通信方式,适用于`任意组件通信`

2. 安装全局事件总线

```js
new Vue({
   // ...
   beforeCreate() {
      Vue.prototype.$bus = this//安装全局事件总线 $bus就是当前应用的vm
   },
   // ...
})
```

3. 使用全局时间总线
   
   1. 接收数据，A组件想接收数据，则A组件在$bus绑定自定义事件，事件回调在A组件自身
   ```
   methods:{
        demo(){},
   }
   mounted(){
      this.$bus.$on("xxx",this.demo)
   }
   ```
   
   2. 提供数据 `this.$bus.$emit("xxx",data..)`
   
   
4. 最好在beforeDestroy钩子中，用$off去解绑当前组件用到的自定义事件

## 消息订阅与发布(pubsub-js)

1. 一种组件间通信方式，使用于任意组件通信

2. 使用步骤

   1. 安装pubsub `npm install pubsub-js`
   2. 引入pubsub `import pubsub from "pubsub-js"`
   3. 接收数据：A组件想要接收数据。则在A组件中订阅消息，订阅消息的回调在A组件自身。
   ```js
   export default {
       methods:{
           demo(){
               // ...
           }
       },
      mounted(){
           this.subId = pubsub.subscribe("schoolName",this.demo)
           // 或者使用箭头函数，因为this指向
           this.subId = pubsub.subscribe("schoolName",()=>{})
      }
   }
   ```
   4. 提供数据：`pubsub.publish("schoolName",data)`
   5. 最好在`beforeDestroy`钩子函数取消订阅，`pubsub.unsubscribe(this.subId)`
   
## nextTick

1. 语法 `this.$nextTick(回调函数)`

2. 作用：再下一次dom更新结束后执行指定回调

3. 什么时候使用：当数据改变后，要基于更新后的dom进行某些操作时，要在nextTick所指定的回调中执行

## vue封装过渡和动画

1. 作用：在插入 更新 或者 移除 DOM元素时，在合适的使用给DOM元素添加样式类名
2. 图示
   ![vue动画图示](https://cn.vuejs.org/images/transition.png)

3. 写法
   1. 准备好样式
      + 元素进入的样式
         1. v-enter：进入的起点
         2. v-enter-active:进入过程中
         3. v-enter-to：进入的终点
      + 元素离开的样式
         1. v-leave：离开的起点
         2. v-leave-active:离开过程中
         3. v-leave-to: 离开的终点
   2. 使用 `<transition></transition>` 包裹要过度的元素，并配置name属性
   ```html
      <transition name="hello">
        <h1 v-show="isShow">hello world</h1>
      </transition>
   ```
   3. 备注：要有多个元素需要过度，则使用：`<transition-group></transition-group>`,并给每个元素指定`key`值